#type for ED calculation
struct EDtable
    state::Dict
    index::Dict
    Snorm;
    dim::Int64
    L::Int64
end
#some tools

function printstate(state,ED::EDtable;tol=1E-12,base=2)
dim=ED.dim
L=ED.L
for i=1:dim
    if abs(state[i])>tol
        println(state[i],"\t",num2basis(ED.state[i],L,base))
    end
end    
end

#Loading EDdata if exist; if not, diagonalize it
function EDdata(H,EDfilename)
    if isfile(EDfilename)
    EDfile=open(EDfilename,"r")
    readdata=deserialize(EDfile)
    E=readdata["E"]
    S=readdata["S"]
    readdata=0;
    close(EDfile)
else
    println("no file: Doing ED calculation.")
sol=eigen(H);
E=sol.values;
S=sol.vectors;
EDdata=Dict()
EDdata["E"]=E;
EDdata["S"]=S;
EDfile=open(EDfilename,"w")
serialize(EDfile,EDdata)
close(EDfile)
end
   return E,S 
end


#functions for ED
#functions
function num2basis(a::Int64,L::Int64,base=2) #convert a state code a to basis, e.g. 1=0000001
    basis=zeros(Int64,L);
    temp=a;
    for i=1:L
        basis[i]=rem(temp,base);
        temp=div(temp,base);
    end
    return basis;    
end

#basis to number converter
function basis2num(basis::Array{Int64},base=2)
    temp=0;
    for i=1:length(basis)
        temp+=basis[i]*base^(i-1);
    end    
    return temp;  
end

#translation operation
function translation(a::Int64,L::Int64,base=2)
    basis=num2basis(a,L,base)
    Tbasis=zeros(Int64,L);
    Tbasis[1]=basis[L];
    Tbasis[2:L]=basis[1:L-1];
    return basis2num(Tbasis,base)
end

function Op_translation(vec,ED,base=2)
    outvec=zeros(eltype(vec),ED.dim)
    for i=1:ED.dim
       a=ED.state[i]
       Ta=translation(a,ED.L,base)
       outvec[ED.index[Ta]]+=vec[i]  
    end
    return outvec
end

#space inversion operation
function inversion(a::Int64,L::Int64,base=2)
   oldarray=num2basis(a,L,base)
   newarray=zeros(Int64,L)
    for i=1:L
    newarray[i]=oldarray[L-i+1]
    end
    return basis2num(newarray,base)
end

function Op_inversion(vec,ED,base=2)
    outvec=zeros(eltype(vec),ED.dim)
    for i=1:ED.dim
       a=ED.state[i]
       Ia=translation(a,ED.L,base)
       outvec[ED.index[Ia]]+=vec[i]  
    end
    return outvec 
end

#function for calculate ED evolution
function evolution(E,S,Δt)
    eiEt=exp.(-1.0im*Δt*E)
    dim1,dim2=size(S)
    U=zeros(complex(Float64),dim1,dim1)
    for i=1:dim1, j=1:dim1
       for k=1:dim2
        U[i,j]+= S[i,k]*eiEt[k]*conj(S[j,k])
        end
    end
    return U
end


#generate states without any symmetry consideration
function GenerateED(L::Int64,base=2;statecheck= i -> true)
    fulldim=base^L
    counter=0;
    state=Dict()
    index=Dict()
    for i=0:fulldim-1
        if statecheck(i)
            counter+=1;
            state[counter]=i;
            index[i]=counter;  
        end
    end
    dim=counter
    ED=EDtable(state,index,nothing,dim,L)
    return ED
end

#generate states with momentum resolution
function GenerateEDK(L::Int64,K::Int64,base=2;tol=1E-14,statecheck= i -> true)
    fulldim=base^L
    counter=0;
    state=Dict()
    index=Dict()
    Snorm=Dict()
    for i=0:fulldim-1
      if statecheck(i)  
        leaststate=i;
        tempstate=i;
        for r=1:L-1   #loop over the translational operation; if the state is the smallest then it's representative
            tempstate=translation(tempstate,L,base);
            tempstate<leaststate ? leaststate=tempstate : nothing
        end
         if leaststate==i
            #determine it's statenorm
            tempnorm=1;
            tempstate=i;
            for r=1:L-1
                tempstate=translation(tempstate,L,base);
                tempstate==i ? tempnorm+=exp(2im*π*K*r/L) : nothing
            end
            
            if abs(tempnorm)>tol  #count the state if statenorm!=0
            counter+=1
            state[counter]=i;
            index[i]=counter;
            Snorm[counter]=sqrt(tempnorm)
            end
          end
        end  #end statecheck  
    end
    dim=counter
    ED=EDtable(state,index,Snorm,dim,L)
    return ED
end

#generate states with momentum resolution + inversion symmetry resolution
function GenerateEDKI(L::Int64,K::Int64,Inv::Bool,base=2;tol=1E-12,statecheck= i -> true)
    fulldim=base^L
    Inv ? Isgn=1 : Isgn=-1;  #sign of the inversion symmetry
    counter=0;
    state=Dict()
    index=Dict()
    Snorm=Dict()
    for i=0:fulldim-1
        if statecheck(i)
        leaststate=i;
        tempstate=i;
        Itempstate=inversion(tempstate,L,base)
        Itempstate<leaststate ? leaststate=Itempstate : nothing
        for r=1:L-1   #loop over the translational operation; if the state is the smallest then it's representative
            tempstate=translation(tempstate,L,base);
            tempstate<leaststate ? leaststate=tempstate : nothing
            Itempstate=inversion(tempstate,L,base)   #checked the inversion symmetry
            Itempstate<leaststate ? leaststate=Itempstate : nothing
        end
         if leaststate==i
            #determine it's statenorm
            tempnorm=1;
            tempstate=i;
            Itempstate=inversion(tempstate,L,base)
            Itempstate==i ? tempnorm+=Isgn : nothing
            for r=1:L-1
                tempstate=translation(tempstate,L,base);
                tempstate==i ? tempnorm+=exp(2im*π*K*r/L) : nothing
                Itempstate=inversion(tempstate,L,base)
                Itempstate==i ? tempnorm+=Isgn*exp(2im*π*K*r/L) : nothing
            end
            
            if abs(tempnorm)>tol  #count the state if statenorm!=0
            counter+=1
            state[counter]=i;
            index[i]=counter;
            Snorm[counter]=sqrt(tempnorm)
            end
          end
        end
    end
    dim=counter
    ED=EDtable(state,index,Snorm,dim,L)
    return ED
end

function findrep(a::Int64,K::Int64,ED::EDtable,base=2)
    L=ED.L
    tempstate=a;
    for r=0:L-1
        if haskey(ED.index,tempstate)
            return tempstate,exp(2im*π*r*K/L) 
        else
            tempstate=translation(tempstate,L,base)
        end
    end
    return -1,0
end

function findrep(a::Int64,K::Int64,Inv::Bool,ED::EDtable,base=2)
    L=ED.L
    Inv ? Isgn=1 : Isgn=-1;  #sign of the inversion symmetry
    tempstate=a;
   
    for r=0:L-1
            Itempstate=inversion(tempstate,L,base)
        if haskey(ED.index,tempstate)
            return tempstate,exp(2im*π*r*K/L) 
        elseif haskey(ED.index,Itempstate)
            return Itempstate,Isgn*exp(2im*π*r*K/L)    
        else
            tempstate=translation(tempstate,L,base)
        end
    end
    return -1,0
end











